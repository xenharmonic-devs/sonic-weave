# SonicWeave standard library
<!-- This file has been auto-generated by `npm run autodoc` i.e. scripts/builtin-docs.ts !-->

## Built-in functions

### absolute(*interval*)
Convert interval to absolute representation. Normalized to a frequency.

### absoluteFJS(*interval*, *flavor = ""*)
Convert interval to absolute FJS.

### acos(*x*)
Calculate acos x.

### arrayReduce(*reducer*, *scale = $$*, *initialValue*)
Reduce the given/current scale to a single value by the `reducer` riff which takes an accumulator, the current value, the current index and the array as arguments.

### arrayRepeat(*count*, *scale = $$*)
Repeat the given/current array or string `count` times.

### asin(*x*)
Calculate asin x.

### atan(*x*)
Calculate atan x.

### atan2(*y*, *x*)
Calculate atan2(y, x) which is the angle between (1, 0) and (x, y), chosen to lie in (−π; π], positive anticlockwise.

### atanXY(*x*, *y*)
Calculate atanXY(x, y) = atan2(y, x) which is the angle between (1, 0) and (x, y), chosen to lie in (−π; π], positive anticlockwise.

### automos()
If the current scale is empty, generate absolute Diamond-mos notation based on the current config.

### basis(*...intervals*)
Construct a subgroup basis from intervals.

### basisOf(*val*)
Return the basis of a val or a temperament.

### basisToArray(*basis*)
Convert a subgroup basis to an array of basis elements.

### bleach(*interval*)
Get rid of interval coloring and label.

### bool(*value*)
Convert value to a boolean.

### ceil(*interval*)
Round value up to the nearest integer.

### cents(*interval*, *fractionDigits*)
Convert interval to cents. `fractionDigits` represents the number of decimal digits in the cents representation. May produce non-algebraic (real) results if number of digits is not given. String arguments are interpreted as denoting cent quantities, not linear fractions.

### centsColor(*interval*)
Color based on the size of the interval. Hue wraps around every 1200 cents.

### charCodeAt(*str*, *index*)
Obtain an integer between 0 and 65535 representing the UTF-16 code unit at the given index.

### clear(*scale = $$*)
Remove the contents of the current/given scale.

### clz32(*x*)
Calculate clz32 x.

### codePointAt(*str*, *index*)
Obtain a non-negative integer that is the Unicode code point value of the character starting at the given index. Note that the index is still based on UTF-16 code units, not Unicode code points.

### colorOf(*interval*)
Return the color of the interval.

### commaBasis(*temperament*)
Obtain the comma basis (null space) of a temperament.

### commaList(*commas*, *basisOrLimit*, *weights*, *pureEquaves*, *fullPrimeLimit*)
Construct a Temperament instance from an array of commas. Optional weights are applied multiplicatively on top of Tenney weights. Optionally equaves are normalized to pure. Optionally the full prime limit is assumed based on the commas.

### compare(*x*, *y*)
Compare two values. Result is -1 if x < y, +1 if x > y and 0 if the arguments are equal.

### complexityOf(*interval*, *countZeros = false*)
Compute the prime limit ordinal of an interval or val. 1/1 has a complexity of 0, 2/1 has complexity 1, 3/1 has complexity 2, 5/1 has complexity 3, etc.. If `countZeros` is true, measure the complexity of the internal representation instead.

### concat(*first*, *...rest*)
Combine two or more arrays/strings.

### cos(*x*)
Calculate cos x.

### decimal(*interval*, *fractionDigits*)
Convert interval to a decimal number.

### det(*matrix*)
Compute the determinant of a matrix. Domain is ignored, all values coerced to linear.

### dir(*arg*)
Obtain the javascript representation of the value.

### dislodge(*element*, *scale = $$*)
Remove and return the first element equal to the given one from the current/given scale.

### distill(*tester*, *scale = $$*)
Remove intervals from the given/current scale that evaluate to `false` according to the `tester` riff.

### divisors(*interval*)
Obtain an array of divisors of a natural number.

### doc(*riff*)
Obtain the docstring of the given riff.

### entries(*record*)
Obtain an array of `[key, value]` pairs of the record.

### errorTE(*val*, *weights*, *unnormalized = false*)
Calculate Tenney-Euclid error w.r.t the vals basis. Weights are applied multiplicatively on top of Tenney weights if given. Unnormalized values are slightly faster to compute and are in the linear domain instead of (logarithmic) cents.

### every(*array = $$*, *test*)
Tests whether all elements in the array pass the test implemented by the provided function. It returns a Boolean value. It doesn't modify the array. If no array is provided it defaults to the current scale. If no test is provided it defaults to truthiness.

### expm1(*x*)
Calculate expm1 x.

### extend(*first*, *...rest*)
Extend the first array with the contents of the rest.

### factorColor(*interval*)
Color an interval based on its prime factors.

### fareyInterior(*maxDenominator*)
Generate the interior of the n'th Farey sequence i.e. all fractions between 0 and 1 exclusive with denominator below or at the given limit.

### fareySequence(*maxDenominator*)
Generate the n'th Farey sequence i.e. all fractions between 0 and 1 inclusive with denominator below or at the given limit.

### filter(*tester*, *scale = $$*)
Obtain a copy of the given/current scale containing values that evaluate to `true` according to the `tester` riff.

### FJS(*interval*, *flavor = ""*)
Convert interval to (relative) FJS.

### flatten(*array*, *depth*)
Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth (default `inf`).

### floor(*interval*)
Round value down to the nearest integer.

### fraction(*interval*, *tolerance*, *preferredNumerator*, *preferredDenominator*)
Convert interval to a fraction. Throws an error if conversion is impossible and no tolerance (in cents) for approximation is given.

### fromCharCode(*...indices*)
Obtain a string created from the specified sequence of UTF-16 code units.

### fromCodePoint(*...indices*)
Obtain a string created from the specified sequence of code points.

### fround(*x*)
Calculate fround x.

### gcd(*x*, *y*)
Obtain the largest (linear) multiplicative factor shared the two arguments or by all intervals or the current scale if no arguments are given.

### generatorsOf(*temperament*)
Obtain the generators of a temperament with period first. See `mappingBasis` for the untempered mapping generators.

### hasConstantStructure(*scale = $$*)
Returns `true` if the current/given scale has constant structure (i.e. every scale degree is unambiguous).

### help(*riff*)
Print information about the given riff to the console.

### hsl(*hue*, *saturation*, *lightness*)
HSL color (Hue range 0-360, Saturation range 0-100, Lightness range 0-100).

### hsla(*hue*, *saturation*, *lightness*, *alpha*)
HSLA color (Hue range 0-360, Saturation range 0-100, Lightness range 0-100, Alpha range 0-1).

### imul(*x*)
Calculate imul x.

### insert(*interval*, *scale = $$*)
Insert an interval into the current/given scale keeping it sorted.

### int(*interval*)
Convert value to an integer. Throws an error if conversion is impossible.

### inv(*matrix*)
Compute the inverse of a matrix. Domain is ignored, all values coerced to linear.

### isAbsolute(*interval*)
Return `true` if the interval belongs to the absolute echelon.

### isArray(*value*)
Return `true` if the value is an array.

### isBasis(*value*)
Return `true` if the value is a basis.

### isBoolean(*value*)
Return `true` if the value is a boolean.

### isColor(*value*)
Return `true` if the value is a color.

### isFunction(*value*)
Return `true` if the value is a riff or an arrow function.

### isInt(*interval*)
Return `true` if the interval is an integer.

### isInterval(*value*)
Return `true` if the value is an interval.

### isLinear(*interval*)
Return `true` if the interval belongs to the linear domain.

### isLogarithmic(*interval*)
Return `true` if the interval belongs to the logarithmic domain.

### isPrime(*n*)
Return `true` if `n` is a prime number, `false` otherwise.

### isRadical(*interval*)
Return `true` if the interval is an nth root.

### isRational(*interval*)
Return `true` if the interval is a rational number.

### isRelative(*interval*)
Return `true` if the interval belongs to the relative echelon.

### isString(*value*)
Return `true` if the value is a string.

### isTemperament(*value*)
Return `true` if the value is a temperament.

### isVal(*value*)
Return `true` if the value is a val.

### JIP(*interval*)
The Just Intonation Point. Converts intervals to real cents.

### kCombinations(*set*, *k*)
Obtain all k-sized combinations in a set

### keepUnique(*scale = ££*)
Obtain a copy of the popped/given scale with only unique intervals kept.

### labelAbsoluteFJS(*interval*, *flavor = ""*)
Convert interval to absolute FJS and label without octaves. Color black if there are accidentals, white otherwise.

### labelOf(*interval*)
Return the label of the interval.

### lcm(*x*, *y*)
Obtain the smallest (linear) interval that shares both arguments as multiplicative factors. Applies to the current scale if not arguments are given.

### length(*scale = $$*)
Return the number of intervals in the scale, the length of a string or the size of a basis.

### linear(*interval*)
Convert interval to linear representation. Formatting information of logarithmic quantities is lost.

### lll(*basis*, *weighting = "tenney"*)
Perform Lensta-Lenstra-Lovász basis reduction.

### log1p(*x*)
Calculate log1p x.

### logarithmic(*interval*)
Convert interval to logarithmic representation. Formatting information of linear quantities is lost.

### map(*mapper*, *scale = $$*)
Map a riff over the given/current scale producing a new scale.

### mappingBasis(*temperament*)
Obtain the mapping generators (preimage) of a temperament with period first. See `generatorsOf` for the tempered generators.

### maximum(*...args*)
Obtain the argument with the maximum value.

### minimum(*...args*)
Obtain the argument with the minimum value.

### monzo(*interval*)
Convert interval to a prime count vector a.k.a. monzo.

### monzoFromPrimeArray(*primeExponents*)
Convert an array of prime counts to a monzo.

### mosSubset(*numberOfLargeSteps*, *numberOfSmallSteps*, *sizeOfLargeStep*, *sizeOfSmallStep*, *up*, *down*)
Calculate a subset of equally tempered degrees with maximum variety two per scale degree.

### nedji(*interval*, *preferredNumerator*, *preferredDenominator*, *preferredEquaveNumerator*, *preferredEquaveDenominator*)
Convert interval to N-steps-of-Equally-Divided-interval-of-Just-Intonation.

### nextGPV(*val*, *weights*)
Obtain the next generalized patent val in the sequence.

### nthPrime(*interval*)
Obtain the nth odd prime or prime 2 if n = 0.

### numComponents(*value*)
Get/set the number of prime exponents to support in monzos. Also sets the length of vals.

### periodsOf(*temperament*)
Obtain the number of periods per equave in a temperament.

### pop(*scale = $$*, *index*)
Remove and return the last interval in the current/given scale. Optionally an index to pop may be given.

### popAll(*scale = $$*)
Remove and return all intervals in the current/given scale.

### PrimeMapping(*...newPrimes*)
Construct a prime mapping for tempering intervals to specified cents. Remaining primes are left untempered.

### primeMonzo(*interval*)
Convert interval to a prime count vector a.k.a. monzo with all primes listed in the subgroup part.

### primeRange(*start*, *end*)
Obtain a range of primes starting at the given ordinal. Prime 2 has ordinal 0. (End - start) elements are returned.

### primes(*start*, *end*)
Obtain an array of prime numbers such that start <= p <= end. Or p <= start if end is omitted.

### print(*...args*)
Print the arguments to the console.

### push(*interval*, *scale = $$*, *index*)
Append an interval onto the current/given scale. Optionally an index to push after may be given.

### radical(*interval*, *maxIndex*, *maxHeight*)
Convert interval to a radical expression. Throws an error if conversion is impossible and no maximum index (2 means square root, 3 means cube root, etc.) for approximation is given.

### random(*...shape*)
Obtain a random value between (linear) 0 and 1.

### randomCents(*...shape*)
Obtain random cents between (logarithmic) 0.0c and 1.0c.

### real(*interval*)
Convert interval to a linear real value.

### relative(*interval*)
Convert interval to relative representation.

### remap(*mapper*, *scale = $$*)
Map a riff over the given/current scale replacing the contents.

### repr(*value*)
Obtain a string representation of the value (with color and label).

### respell(*commaBasis*, *searchRadius*)
Respell i.e. simplify fractions in the the current scale treating intervals separated by the given commas as the same. Search radius (default 1) is an integer for discovering harder-to-find simplifications. (Creates a respelling function.)

### reverse(*scale = ££*)
Obtain a copy of the popped/given scale in reversed order.

### reverseInPlace(*scale = $$*)
Reverse the order of the current/given scale.

### rgb(*red*, *green*, *blue*)
RGB color (Red range 0-255, Green range 0-255, Blue range 0-255).

### rgba(*red*, *green*, *blue*, *alpha*)
RGBA color (Red range 0-255, Green range 0-255, Blue range 0-255, Alpha range 0-1).

### round(*interval*)
Round value to the nearest integer.

### shift(*scale = $$*)
Remove and return the first interval in the current/given scale.

### simplify(*interval*)
Get rid of interval formatting. Simplifies a ratio to lowest terms.

### sin(*x*)
Calculate sin x.

### slice(*array*, *indexStart*, *indexEnd*)
Obtain a slice of a string or scale between the given indices.

### some(*array = $$*, *test*)
Test whether at least one element in the array passes the test implemented by the provided function. It returns true if, in the array, it finds an element for which the provided function returns true; otherwise it returns false. It doesn't modify the array. If no array is provided it defaults to the current scale. If no test is provided it defaults to truthiness.

### sort(*scale = ££*, *compareFn*)
Obtain a sorted copy of the popped/given scale in ascending order.

### sortInPlace(*scale = $$*, *compareFn*)
Sort the current/given scale in ascending order.

### SOV(*val*)
Format a val using Sparse Offset Val notation.

### stepSignature(*word*)
Calculate the step signature of an entire scale word.

### stepString(*scale = $$*)
Obtain the step string associated with the scale e.g. "LLsLLLs" for Ionian.

### str(*value*)
Obtain a string representation of the value (w/o color or label).

### tail(*interval*, *index*)
Return the higher prime tail of an interval starting from the given index. Prime 2 has index 0.

### tan(*x*)
Calculate tan x.

### Temperament(*vals*, *weights*, *pureEquaves*)
Construct a Temperament instance from an array of vals. Optional weights are applied multiplicatively on top of Tenney weights. Optionally equaves are normalized to pure.

### templateArg(*index*)
Access the nth template argument when using the `sw` tag inside JavaScript.

### tenneyHeight(*interval*)
Calculate the Tenney height of the interval. Natural logarithm of numerator times denominator.

### toPrimeArray(*interval*)
Convert interval to an array of its prime counts.

### track(*interval*)
Attach a tracking ID to the interval.

### trackingIds(*interval*)
Obtain an array of the tracking IDs attached to the interval.

### transpose(*matrix*)
Transpose a matrix. For modal transposition see rotate().

### trunc(*interval*)
Truncate value towards zero to the nearest integer.

### tune(*vals*, *searchRadius*, *weights*)
Attempt to combine the given vals into a more Tenney-Euclid optimal val. Weights are applied multiplicatively on top of Tenney weights of the subgroup basis.

### unshift(*interval*, *scale = $$*)
Prepend an interval at the beginning of the current/given scale.

### valFromPrimeArray(*primeExponents*, *basis*)
Convert an array of prime mapping entries to a val.

### vstr(*value*)
Obtain a string representation of a primitive value (w/o color or label). Vectorizes over arrays.

### warn(*...args*)
Print the arguments to the console with "warning" emphasis.

### warts(*val*)
Format a val using warts shorthand notation.

### wilsonHeight(*interval*)
Calculate the Wilson height of the interval. Sum of prime absolute factors with repetition..

### withBasis(*val*, *basis*)
Change the basis of the val.

### zip(*...args*)
Combine elements of each array into tuples until one of them is exhausted.

### zipLongest(*...args*)
Combine elements of each array into tuples until all of them are exhausted. Pads missing values with `niente`.

## Prelude functions

### ablin(*interval*)
Convert interval to absolute linear representation.

### ablog(*interval*)
Convert interval to absolute logarithmic representation.

### absoluteHEJI(*interval*)
Convert interval to absolute FJS using HEJI comma flavors.

### absoluteNFJS(*interval*)
Convert interval to absolute FJS using neutral comma flavors.

### acosh(*x*)
Calculate the inverse hyperbolic cosine of x.

### add(*...terms*)
Calculate the (linear) sum of the arguments.

### afdo(*divisions*, *equave = 2*)
Generate arithmetic frequency divisions of the given equave/octave.

### afdoStack(*steps*, *equave = 2*)
Stack arithmetic frequency deltas up to the given equave/octave.

### asinh(*x*)
Calculate the inverse hyperbolic sine of x.

### assert(*test*, *message = "Assertion failed."*)
Assert that the test expression is true or fail with the given message.

### atanh(*x*)
Calculate the inverse hyperbolic tangent of x.

### avg(*...terms*)
Calculate the arithmetic mean of the terms.

### bpm(*beats*)
Calculate the frequency corresponding to the given number of beats per minute.

### cbrt(*x*)
Calculate the cube root of the input.

### circleDifference(*a*, *b*, *equave = 2*)
Calculate the geometric difference of two intervals on a circle.

### circleDistance(*a*, *b*, *equave = 2*)
Calculate the geometric distance of two intervals on a circle.

### coalesce(*tolerance = 3.5*, *action = "simplest"*, *preserveBoundary = false*, *scale = ££*)
Obtain a copy of the popped/given scale where groups of intervals separated by `tolerance` are coalesced into one.  `action` is one of 'simplest', 'wilson', 'lowest', 'highest', 'avg', 'havg' or 'geoavg'.  If `preserveBoundary` is `true` intervals close to unison and the equave are not eliminated.

### colorsOf(*scale = $$*)
Obtain an array of colors of the current/given scale.

### concordanceShell(*denominator*, *maxNumerator*, *divisions = 12*, *tolerance = 5.0*, *equave = 2*)
Generate a concordance shell i.e. a vertically aligned object reduced to an equal temperament. Intervals are labeled by their harmonics.

### cosh(*x*)
Calculate the hyperbolic cosine of x.

### cps(*factors*, *count*, *equave = 2*, *withUnity = false*)
Generate a combination product set from the given factors and combination size.

### csgs(*generators*, *ordinal = 1*, *period = 2*, *numPeriods = 1*, *maxSize = 100*)
Generate a constant structure generator sequence. Zero ordinal corresponds to the (trivial) stack of all generators while positive ordinals denote scales with constant structure ordered by increasing size.

### CTE(*valsOrCommas*, *primeLimit = niente*)
Create a constrained (nearly) Tenney-Euclid optimal temperament from an array of vals or commas. Note: Comma lists will always use the full inferred prime limit, but a higher one or an explicit basis can be given.

### cumprod(*array*)
Calculate the cumulative products of the factors in the array i.e. logarithmic cumulative sums.

### cumsum(*array*)
Calculate the cumulative sums of the terms in the array.

### denominator(*x*)
Calculate the denominator of x in reduced form.

### diff(*array*)
Calculate the (linear) differences between the terms.

### domainOf(*interval*)
Return the domain of the given interval as a callable converter.

### edColors(*divisions = 12*, *offset = 0*, *equave = 2*)
Color every interval in the scale with hue repeating every step of an equal division of `equave`. `offset` rotates the hue wheel.

### elevate(*scale = ££*)
Obtain a copy of the popped/given scale with denominators removed and the root made explicit.

### enumerate(*array = $$*)
Produce an array of [index, element] pairs from the given current/given array.

### equalize(*divisions*, *scale = ££*)
Obtain a copy of the popped/given scale quantized to given equal divisions of its equave.

### equaveReduce(*scale = ££*)
Obtain a copy of the popped/given scale reduced by its equave.

### eulerGenus(*guide*, *root = 1*, *equave = 2*)
Span a lattice from all divisors of the guide-tone rotated to the root-tone.

### exp(*x*)
Calculate e raised to the power of x.

### fail(*message*)
Throw the given message as an error.

### ftom(*freq*)
Convert absolute frequency to MIDI note number / MTS value (fractional semitones with A440 = 69).

### geoavg(*...factors*)
Calculate the geometric mean of the factors.

### geodiff(*array*)
Calculate the geometric differences between the factors.

### ground(*scale = ££*)
Obtain a copy of the popped/given scale that uses the first interval as the implicit unison.

### gs(*generators*, *size*, *period = 2*, *numPeriods = 1*)
Stack a periodic array of generators up to the given size which must be a multiple of the number of periods.

### havg(*...terms*)
Calculate the harmonic mean of the terms.

### HEJI(*interval*)
Convert interval to (relative) FJS using HEJI comma flavors.

### hypot(*...args*)
Calculate the square root of the sum of squares of the arguments.

### keys(*record*)
Obtain an array of keys of the record.

### labelsOf(*scale = $$*)
Obtain an array of labels of the current/given scale.

### log(*x*, *y = E*)
Calculate the logarithm of x base y. Base defaults to E.

### log10(*x*)
Calculate the logarithm of x base 10.

### log2(*x*)
Calculate the logarithm of x base 2.

### mergeOffset(*offsets*, *overflow = "drop"*, *scale = ££*)
Obtain a copy of the popped/given scale with the given offset or polyoffset merged into it. `overflow` is one of 'keep', 'drop' or 'wrap' and controls what to do with offset intervals outside of current bounds.

### mos(*numberOfLargeSteps*, *numberOfSmallSteps*, *sizeOfLargeStep = 2*, *sizeOfSmallStep = 1*, *up = niente*, *down = niente*, *equave = 2*)
Generate a Moment-Of-Symmetry scale with the given number number of large and small steps.   `up` defines the brightness of the mode i.e. the number of major intervals from the root.   Alternatively `down` defines the darkness of the mode i.e. the number of minor intervals from the root.   The default `equave` is the octave `2/1`.

### mtof(*index*)
Convert MIDI note number to absolute frequency.

### mul(*...factors*)
Calculate the (linear) product of the arguments i.e. the logarithmic sum.

### NFJS(*interval*)
Convert interval to (relative) FJS using neutral comma flavors.

### numerator(*x*)
Calculate the numerator of x in reduced form.

### o(*scale = ££*)
Obtain a copy of the popped/given scale in the default overtonal interpretation.

### octaplex(*b0*, *b1*, *b2*, *b3*, *equave = 2*, *withUnity = false*)
Generate a 4-dimensional octaplex a.k.a. 20-cell from the given basis intervals.

### oddLimit(*limit*, *equave = 2*)
Generate all fractions with odd limit <= `limit` reduced to between 1 (exclusive) and `equave` (inclusive).

### oddLimitOf(*x*, *equave = 2*)
Calculate the odd limit of x. Here 'odd' means not divisible by the equave.

### organize(*tolerance = niente*, *action = "simplest"*, *preserveBoundary = false*, *scale = ££*)
Obtain a copy of the popped/given scale reduced by its last interval, sorted and with duplicates filtered out.  If `tolerance` is given near-duplicates are coalesced instead using the given `action`.  If `preserveBoundary` is `true` intervals close to unison and the equave are not eliminated.

### parallelotope(*basis*, *ups = niente*, *downs = niente*, *equave = 2*, *basisSizeHints = niente*, *equaveSizeHint = niente*)
Span a parallelotope by extending a basis combinatorically. `ups` defaults to all ones while `downs` defaults to all zeros.  The size hints are used to get the correct period reduction when generating a preimage.

### POTE(*valsOrCommas*, *primeLimit = niente*)
Create a naïve pure-equaves tuning by normalizing the Tenney-Euclid optimal temperament based on an array of vals or commas. Note: Comma lists will always use the full inferred prime limit, but a higher one or an explicit basis can be given.

### pow(*x*, *y*)
Calculate x to the power of y.

### prod(*factors = $$*)
Calculate the (linear) product of the factors or the current scale i.e. the logarithmic sum.

### randomVariance(*amount*, *varyEquave = false*, *scale = ££*)
Obtain a copy of the popped/given scale with random variance added.

### range(*start*, *stop = niente*, *step = 1*)
Obtain an array of integers from `start` to `stop - 1`. When only a single parameter is given `range(0, n)` is returned.

### rank2(*generator*, *up*, *down = 0*, *period = 2*, *numPeriods = 1*, *generatorSizeHint = niente*, *periodSizeHint = niente*)
Create a finite segment of a Rank-2 scale by stacking the given generator against the given period (or the octave `2/1` by default).  `up` and `down` must be multiples of `numPeriods`. The size hints are used to get the correct period reduction when generating a preimage.

### realizeWord(*word*, *sizes*, *equave = niente*)
Realize a scale word like "LLsLLLs" as a concrete scale with the given step sizes. One step size may be omitted and inferred based on the size of the `equave` (default `2`).

### reduce(*scale = ££*)
Obtain a copy of the popped/given scale reduced by its equave. Issue a warning if the scale was already reduced.

### reflect(*scale = ££*)
Obtain a copy of the popped/given scale reflected about unison.

### relin(*interval*)
Convert interval to relative linear representation.

### relog(*interval*)
Convert interval to relative logarithmic representation.

### repeat(*times = 2*, *scale = ££*)
Stack the popped/given scale on top of itself.

### repeatFlat(*times = 2*, *scale = ££*)
Repeat the popped/given intervals as-is without accumulating equaves.

### repeatLinear(*times = 2*, *scale = ££*)
Repeat the popped/given scale shifted linearly each time.

### replace(*interval*, *replacement*, *scale = ££*)
Obtain a copy of the popped/given scale with occurences of `interval` replaced by `replacement`.

### replaceStep(*step*, *replacement*, *scale = ££*)
Obtain a copy of the popped/given scale with relative occurences of `step` replaced by `replacement`.

### retrovert(*scale = ££*)
Obtain an retroverted copy of the popped/given scale (negative harmony i.e. reflect and transpose).

### revpose(*scale = ££*)
Obtain a copy of the popped/given scale that sounds in the opposite direction.

### rotate(*onto = 1*, *scale = ££*)
Obtain a copy of the popped/given scale rotated onto the given degree.

### sanitize(*interval*)
Get rid of interval formatting, color and label.

### sign(*x*)
Calculate the sign of x.

### sinh(*x*)
Calculate the hyperbolic sine of x.

### sqrt(*x*)
Calculate the square root of the input.

### stack(*array = ££*)
Cumulatively stack the popped/given intervals on top of each other.

### stackLinear(*array = ££*)
Cumulatively sum the numbers of the popped/given array.

### stackPeriodic(*guideGenerator*, *array = ££*)
Stack the popped/given inflections along with the guide generator into a periodic sequence of steps.

### stretch(*amount*, *scale = ££*)
Obtain a copy of the popped/given scale streched by the given amount. A value of `1` corresponds to no change.

### subharmonics(*start*, *end*)
Generate a subharmonic segment including the given start and end points.

### subset(*degrees*, *scale = ££*)
Obtain a copy of the popped/given scale with only the given degrees kept. Omitting the zero degree rotates the scale.

### sum(*terms = $$*)
Calculate the (linear) sum of the terms or the current scale.

### supportingGPVs(*initialVal*, *commas*, *count = 5*, *weights = niente*, *maxIter = 1000*)
Obtain generalized patent vals in the same sequence as the initial val that make the given commas vanish.

### tanh(*x*)
Calculate the hyperbolic tangent of x.

### TE(*valsOrCommas*, *basis = niente*)
Create a Tenney-Euclid optimal temperament from an array of vals or commas. Note: Comma lists will always use the full inferred prime limit, but a different basis or a prime limit may be given.

### tet(*divisions*, *equave = 2*)
Generate an equal temperament with the given number of divisions of the given equave/octave.

### tetStack(*steps*, *equave = 2*)
Stack relative edosteps up to the given equave/octave.

### toHarmonics(*fundamental*, *scale = ££*)
Obtain a copy of the popped/given scale quantized to harmonics of the given fundamental.

### toSubharmonics(*overtone*, *scale = ££*)
Obtain a copy of the current/given scale quantized to subharmonics of the given overtone.

### trap(*message*)
Produce a function that fails with the given message when called.

### u(*scale = ££*)
Obtain a undertonal reflection of the popped/given overtonal scale.

### unstack(*array = ££*)
Unstack the popped/given scale into steps.

### unstackPeriodic(*array = ££*)
Convert the popped/given periodic sequence of steps into inflections of the last interval as the guide generator.

### values(*record*)
Obtain an array of values of the record.

### vao(*denominator*, *maxNumerator*, *divisions = 12*, *tolerance = 5.0*, *equave = 2*)
Generate a vertically aligned object i.e. a subset of the harmonic series that sounds like the given equal temperament (default `12`) within the given tolerance (default `5c`). Harmonics equated by the `equave` (default `2/1`) are only included once. The returned segment begins at unison.

### vbool(*value*)
Convert value to a boolean. Vectorizes over arrays.

### void()
Get rid of expression results. `void(++i)` increments the value but doesn't push anything onto the scale.

### weilHeight(*x*)
Calculate the Weil height of the interval. Natural logarithm of the maximum of numerator or denominator.

### wellTemperament(*commaFractions*, *comma = 81/80*, *down = 0*, *generator = 3/2*, *period = 2*)
Generate a well-temperament by cumulatively modifying the pure fifth `3/2` (or a given generator) by fractions of the syntonic/given comma.

