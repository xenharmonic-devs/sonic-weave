# SonicWeave standard library
<!-- This file has been auto-generated by `npm run autodoc` i.e. scripts/builtin-docs.ts !-->

## Built-in functions

### abs(*interval*)
Calculate the absolute value of the interval.

### absolute(*interval*)
Convert interval to absolute representation. Normalized to a frequency.

### absoluteFJS(*interval*, *flavor = ""*)
Convert interval to absolute FJS.

### acos(*x*)
Calculate acos x.

### arrayReduce(*reducer*, *scale = $$*, *initialValue*)
Reduce the given/current scale to a single value by the `reducer` riff which takes an accumulator, the current value, the current index and the array as arguments.

### arrayRepeat(*count*, *scale = $$*)
Repeat the given/current array or string `count` times.

### asin(*x*)
Calculate asin x.

### atan(*x*)
Calculate atan x.

### atan2(*y*, *x*)
Calculate atan2(y, x) which is the angle between (1, 0) and (x, y), chosen to lie in (−π; π], positive anticlockwise.

### atanXY(*x*, *y*)
Calculate atanXY(x, y) = atan2(y, x) which is the angle between (1, 0) and (x, y), chosen to lie in (−π; π], positive anticlockwise.

### bleach(*interval*)
Get rid of interval coloring and label.

### bool(*value*)
Convert value to a boolean.

### ceil(*interval*)
Round value up to the nearest integer.

### cents(*interval*, *fractionDigits*)
Convert interval to cents. `fractionDigits` represents the number of decimal digits in the cents representation. May produce non-algebraic (real) results if number of digits is not given. String arguments are interpreted as denoting cent quantities, not linear fractions.

### centsColor(*interval*)
Color based on the size of the interval. Hue wraps around every 1200 cents.

### charCodeAt(*str*, *index*)
Obtain an integer between 0 and 65535 representing the UTF-16 code unit at the given index.

### clear(*scale = $$*)
Remove the contents of the current/given scale.

### clz32(*x*)
Calculate clz32 x.

### codePointAt(*str*, *index*)
Obtain a non-negative integer that is the Unicode code point value of the character starting at the given index. Note that the index is still based on UTF-16 code units, not Unicode code points.

### colorOf(*interval*)
Return the color of the interval.

### complexityOf(*interval*, *countZeros = false*)
Compute the prime limit ordinal of an interval or val. 1/1 has a complexity of 0, 2/1 has complexity 1, 3/1 has complexity 2, 5/1 has complexity 3, etc.. If `countZeros` is true, measure the complexity of the internal representation instead.

### concat(*first*, *...rest*)
Combine two or more arrays/strings.

### cos(*x*)
Calculate cos x.

### cosJIP(*val*, *weighting = "tenney"*)
Cosine of the angle between the val and the just intonation point. Weighting is either "none", "tenney" or "wilson".

### decimal(*interval*, *fractionDigits*)
Convert interval to a decimal number.

### dir(*arg*)
Obtain the javascript representation of the value.

### dislodge(*element*, *scale = $$*)
Remove and return the first element equal to the given one from the current/given scale.

### distill(*tester*, *scale = $$*)
Remove intervals from the given/current scale that evaluate to `false` according to the `tester` riff.

### divisors(*interval*)
Obtain an array of divisors of a natural number.

### doc(*riff*)
Obtain the docstring of the given riff.

### entries(*record*)
Obtain an array of `[key, value]` pairs of the record.

### equaveOf(*val*)
Return the equave of the val.

### every(*array*, *test*)
Tests whether all elements in the array pass the test implemented by the provided function. It returns a Boolean value. It doesn't modify the array. If no array is provided it defaults to the current scale. If no test is provided it defaults to truthiness.

### expm1(*x*)
Calculate expm1 x.

### extend(*first*, *...rest*)
Extend the first array with the contents of the rest.

### factorColor(*interval*)
Color an interval based on its prime factors.

### fareyInterior(*maxDenominator*)
Generate the interior of the n'th Farey sequence i.e. all fractions between 0 and 1 exclusive with denominator below or at the given limit.

### fareySequence(*maxDenominator*)
Generate the n'th Farey sequence i.e. all fractions between 0 and 1 inclusive with denominator below or at the given limit.

### filter(*tester*, *scale = $$*)
Obtain a copy of the given/current scale containing values that evaluate to `true` according to the `tester` riff.

### FJS(*interval*, *flavor = ""*)
Convert interval to (relative) FJS.

### flatten(*array*, *depth*)
Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth (default `Infinity`).

### floor(*interval*)
Round value down to the nearest integer.

### fraction(*interval*, *tolerance*, *preferredNumerator*, *preferredDenominator*)
Convert interval to a fraction. Throws an error if conversion is impossible and no tolerance (in cents) for approximation is given.

### fromCharCode(*...indices*)
Obtain a string created from the specified sequence of UTF-16 code units.

### fromCodePoint(*...indices*)
Obtain a string created from the specified sequence of code points.

### fround(*x*)
Calculate fround x.

### gcd(*x*, *y*)
Obtain the largest (linear) multiplicative factor shared the two arguments or by all intervals or the current scale if no arguments are given.

### hasConstantStructure(*scale = $$*)
Returns `true` if the current/given scale has constant structure (i.e. every scale degree is unambiguous).

### help(*riff*)
Print information about the given riff to the console.

### hsl(*hue*, *saturation*, *lightness*)
HSL color (Hue range 0-360, Saturation range 0-100, Lightness range 0-100).

### hsla(*hue*, *saturation*, *lightness*, *alpha*)
HSLA color (Hue range 0-360, Saturation range 0-100, Lightness range 0-100, Alpha range 0-1).

### imul(*x*)
Calculate imul x.

### insert(*interval*, *scale = $$*)
Insert an interval into the current/given scale keeping it sorted.

### int(*interval*)
Convert value to an integer. Throws an error if conversion is impossible.

### isAbsolute(*interval*)
Return `true` if the interval belongs to the absolute echelon.

### isArray(*value*)
Return `true` if the value is an array.

### isBoolean(*value*)
Return `true` if the value is a boolean.

### isColor(*value*)
Return `true` if the value is a color.

### isFunction(*value*)
Return `true` if the value is a riff or an arrow function.

### isInt(*interval*)
Return `true` if the interval is an integer.

### isInterval(*value*)
Return `true` if the value is an interval.

### isLinear(*interval*)
Return `true` if the interval belongs to the linear domain.

### isLogarithmic(*interval*)
Return `true` if the interval belongs to the logarithmic domain.

### isPrime(*n*)
Return `true` if `n` is a prime number, `false` otherwise.

### isRadical(*interval*)
Return `true` if the interval is an nth root.

### isRational(*interval*)
Return `true` if the interval is a rational number.

### isRelative(*interval*)
Return `true` if the interval belongs to the relative echelon.

### isString(*value*)
Return `true` if the value is a string.

### JIP(*interval*)
The Just Intonation Point. Converts intervals to real cents.

### kCombinations(*set*, *k*)
Obtain all k-sized combinations in a set

### keepUnique(*scale = $$*)
Only keep unique intervals in the current/given scale.

### labelAbsoluteFJS(*interval*, *flavor = ""*)
Convert interval to absolute FJS and label without octaves. Color black if there are accidentals, white otherwise.

### labelOf(*interval*)
Return the label of the interval.

### lcm(*x*, *y*)
Obtain the smallest (linear) interval that shares both arguments as multiplicative factors. Applies to the current scale if not arguments are given.

### length(*scale = $$*)
Return the number of intervals in the scale.

### linear(*interval*)
Convert interval to linear representation.

### log1p(*x*)
Calculate log1p x.

### logarithmic(*interval*)
Convert interval to logarithmic representation.

### map(*mapper*, *scale = $$*)
Map a riff over the given/current scale producing a new scale.

### maximum(*...args*)
Obtain the argument with the maximum value.

### minimum(*...args*)
Obtain the argument with the minimum value.

### monzo(*interval*)
Convert interval to a prime count vector a.k.a. monzo.

### monzoFromPrimeArray(*primeExponents*)
Convert an array of prime counts to a monzo.

### mosSubset(*numberOfLargeSteps*, *numberOfSmallSteps*, *sizeOfLargeStep*, *sizeOfSmallStep*, *up*, *down*)
Calculate a subset of equally tempered degrees with maximum variety two per scale degree.

### nedji(*interval*, *preferredNumerator*, *preferredDenominator*, *preferredEquaveNumerator*, *preferredEquaveDenominator*)
Convert interval to N-steps-of-Equally-Divided-interval-of-Just-Intonation.

### nthPrime(*interval*)
Obtain the nth odd prime or prime 2 if n = 0.

### numComponents(*value*)
Get/set the number of prime exponents to support in monzos. Also sets the length of vals.

### pop(*scale = $$*, *index*)
Remove and return the last interval in the current/given scale. Optionally an index to pop may be given.

### popAll(*scale = $$*)
Remove and return all intervals in the current/given scale.

### PrimeMapping(*...newPrimes*)
Construct a prime mapping for tempering intervals to specified cents. Remaining primes are left untempered.

### primeMonzo(*interval*)
Convert interval to a prime count vector a.k.a. monzo with all primes listed in the subgroup part.

### primeRange(*start*, *end*)
Obtain a range of primes starting at the given ordinal. Prime 2 has ordinal 0. (End - start) elements are returned.

### primes(*start*, *end*)
Obtain an array of prime numbers such that start <= p <= end. Or p <= start if end is omitted.

### print(*...args*)
Print the arguments to the console.

### push(*interval*, *scale = $$*, *index*)
Append an interval onto the current/given scale. Optionally an index to push after may be given.

### radical(*interval*, *maxIndex*, *maxHeight*)
Convert interval to a radical expression. Throws an error if conversion is impossible and no maximum index (2 means square root, 3 means cube root, etc.) for approximation is given.

### random(*...shape*)
Obtain a random value between (linear) 0 and 1.

### randomCents(*...shape*)
Obtain random cents between (logarithmic) 0.0c and 1.0c.

### real(*interval*)
Convert interval to a linear real value.

### relative(*interval*)
Convert interval to relative representation.

### remap(*mapper*, *scale = $$*)
Map a riff over the given/current scale replacing the contents.

### repr(*value*)
Obtain a string representation of the value (with color and label).

### reverse(*scale = $$*)
Reverse the order of the current/given scale.

### reversed(*scale = $$*)
Obtain a copy of the current/given scale in reversed order.

### rgb(*red*, *green*, *blue*)
RGB color (Red range 0-255, Green range 0-255, Blue range 0-255).

### rgba(*red*, *green*, *blue*, *alpha*)
RGBA color (Red range 0-255, Green range 0-255, Blue range 0-255, Alpha range 0-1).

### round(*interval*)
Round value to the nearest integer.

### shift(*scale = $$*)
Remove and return the first interval in the current/given scale.

### simplify(*interval*)
Get rid of interval formatting. Simplifies a ratio to lowest terms.

### sin(*x*)
Calculate sin x.

### slice(*array*, *indexStart*, *indexEnd*)
Obtain a slice of a string or scale between the given indices.

### some(*array*, *test*)
Test whether at least one element in the array passes the test implemented by the provided function. It returns true if, in the array, it finds an element for which the provided function returns true; otherwise it returns false. It doesn't modify the array. If no array is provided it defaults to the current scale. If no test is provided it defaults to truthiness.

### sort(*scale = $$*, *compareFn*)
Sort the current/given scale in ascending order.

### sorted(*scale = $$*, *compareFn*)
Obtain a sorted copy of the current/given scale in ascending order.

### stepSignature(*word*)
Calculate the step signature of an entire scale word.

### stepString(*scale = $$*)
Obtain the step string associated with the scale e.g. "LLsLLLs" for Ionian.

### str(*value*)
Obtain a string representation of the value (w/o color or label).

### tail(*interval*, *index*)
Return the higher prime tail of an interval starting from the given index. Prime 2 has index 0.

### tan(*x*)
Calculate tan x.

### templateArg(*index*)
Access the nth template argument when using the `sw` tag inside JavaScript.

### tenneyHeight(*interval*)
Calculate the Tenney height of the interval. Natural logarithm of numerator times denominator.

### toPrimeArray(*interval*)
Convert interval to an array of its prime counts.

### track(*interval*)
Attach a tracking ID to the interval.

### trackingIds(*interval*)
Obtain an array of the tracking IDs attached to the interval.

### transpose(*matrix*)
Transpose a matrix. For modal transposition see rotate().

### trunc(*interval*)
Truncate value towards zero to the nearest integer.

### uniquesOf(*scale = $$*)
Obtain a copy of the current/given scale with only unique intervals kept.

### unshift(*interval*, *scale = $$*)
Prepend an interval at the beginning of the current/given scale.

### valFromPrimeArray(*primeExponents*, *equave*)
Convert an array of prime mapping entries to a val.

### warn(*...args*)
Print the arguments to the console with "warning" emphasis.

### wilsonHeight(*interval*)
Calculate the Wilson height of the interval. Sum of prime absolute factors with repetition..

### withEquave(*val*, *equave*)
Change the equave of the val.

### zip(*...args*)
Combine elements of each array into tuples until one of them is exhausted.

### zipLongest(*...args*)
Combine elements of each array into tuples until all of them are exhausted. Pads missing values with `niente`.

## Prelude functions

### ablin(*interval*)
Convert interval to absolute linear representation.

### ablog(*interval*)
Convert interval to absolute logarithmic representation.

### absoluteHEJI(*interval*)
Convert interval to absolute FJS using HEJI comma flavors.

### absoluteNFJS(*interval*)
Convert interval to absolute FJS using neutral comma flavors.

### acosh(*x*)
Calculate the inverse hyperbolic cosine of x.

### add(*...terms*)
Calculate the (linear) sum of the arguments.

### antiperiodiff(*constantOfIntegration*, *array*)
Calculate the cumulative geometric sums of a periodic difference pattern. Undoes what periodiff does.

### asinh(*x*)
Calculate the inverse hyperbolic sine of x.

### assert(*test*, *message = "Assertion failed."*)
Assert that the test expression is true or fail with the given message.

### atanh(*x*)
Calculate the inverse hyperbolic tangent of x.

### avg(*...terms*)
Calculate the arithmetic mean of the terms.

### bpm(*beats*)
Calculate the frequency corresponding to the given number of beats per minute.

### cbrt(*x*)
Calculate the cube root of the input.

### circleDifference(*a*, *b*, *equave = 2*)
Calculate the geometric difference of two intervals on a circle.

### circleDistance(*a*, *b*, *equave = 2*)
Calculate the geometric distance of two intervals on a circle.

### coalesce(*tolerance = 3.5*, *action = "simplest"*, *preserveBoundary = false*, *scale = $$*)
Coalesce intervals in the current/given scale separated by `tolerance` (default 3.5 cents) into one.    `action` is one of 'simplest', 'wilson', 'lowest', 'highest', 'avg', 'havg' or 'geoavg' defaulting to 'simplest'.   If `preserveBoundary` is `true` intervals close to unison and the equave are not eliminated.

### coalesced(*tolerance = 3.5*, *action = "simplest"*, *preserveBoundary = false*, *scale = $$*)
Obtain a copy of the current/given scale where groups of intervals separated by `tolerance` are coalesced into one.  `action` is one of 'simplest', 'wilson', 'lowest', 'highest', 'avg', 'havg' or 'geoavg'.  If `preserveBoundary` is `true` intervals close to unison and the equave are not eliminated.

### colorsOf(*scale = $$*)
Obtain an array of colors of the current/given scale.

### concordanceShell(*denominator*, *maxNumerator*, *divisions = 12*, *tolerance = 5.0*, *equave = 2*)
Generate a concordance shell i.e. a vertically aligned object reduced to an equal temperament. Intervals are labeled by their harmonics.

### cosh(*x*)
Calculate the hyperbolic cosine of x.

### cps(*factors*, *count*, *equave = 2*, *withUnity = false*)
Generate a combination product set from the given factors and combination size.

### csgs(*generators*, *ordinal = 1*, *period = 2*, *numPeriods = 1*, *maxSize = 100*)
Generate a constant structure generator sequence. Zero ordinal corresponds to the (trivial) stack of all generators while positive ordinals denote scales with constant structure ordered by increasing size.

### cumprod(*array*)
Calculate the cumulative products of the factors in the array i.e. logarithmic cumulative sums.

### cumsum(*array*)
Calculate the cumulative sums of the terms in the array.

### denominator(*x*)
Calculate the denominator of x in reduced form.

### diff(*array*)
Calculate the (linear) differences between the terms.

### domainOf(*interval*)
Return the domain of the given interval as a callable converter.

### edColors(*divisions = 12*, *offset = 0*, *equave = 2*)
Color every interval in the scale with hue repeating every step of an equal division of `equave`. `offset` rotates the hue wheel.

### elevate(*scale = $$*)
Remove denominators and make the root explicit in the current/given scale.

### elevated(*scale = $$*)
Obtain a copy of the current/given scale with denominators removed and the root made explicit.

### enumerate(*array = $$*)
Produce an array of [index, element] pairs from the given current/given array.

### equalize(*divisions*, *scale = $$*)
Quantize the current/given scale to given equal divisions of its equave.

### equalized(*divisions*, *scale = $$*)
Obtain a copy of the current/given scale quantized to given equal divisions of its equave.

### equaveReduce(*scale = $$*)
Reduce the current/given scale by its equave.

### equaveReduced(*scale = $$*)
Obtain a copy of the current/given scale reduced by its equave.

### eulerGenus(*guide*, *root = 1*, *equave = 2*)
Span a lattice from all divisors of the guide-tone rotated to the root-tone.

### exp(*x*)
Calculate e raised to the power of x.

### fail(*message*)
Throw the given message as an error.

### flatRepeat(*times = 2*, *scale = $$*)
Repeat the current/given intervals as-is without accumulating equaves. Clears the scale if the number of repeats is zero.

### ftom(*freq*)
Convert absolute frequency to MIDI note number / MTS value (fractional semitones with A440 = 69).

### geoavg(*...factors*)
Calculate the geometric mean of the factors.

### geodiff(*array*)
Calculate the geometric differences between the factors.

### ground(*scale = $$*)
Use the first interval in the current/given scale as the implicit unison.

### grounded(*scale = $$*)
Obtain a copy of the current/given scale that uses the first interval as the implicit unison.

### gs(*generators*, *size*, *period = 2*, *numPeriods = 1*)
Stack a periodic array of generators up to the given size which must be a multiple of the number of periods.

### harmonicsOf(*fundamental*, *scale = $$*)
Obtain a copy of the current/given scale quantized to harmonics of the given fundamental.

### havg(*...terms*)
Calculate the harmonic mean of the terms.

### HEJI(*interval*)
Convert interval to (relative) FJS using HEJI comma flavors.

### hypot(*...args*)
Calculate the square root of the sum of squares of the arguments.

### keys(*record*)
Obtain an array of keys of the record.

### label(*labels*, *scale = $$*)
Apply labels (or colors) from the first array to the current/given scale. Can also apply a single color to the whole scale.

### labeled(*labels*, *scale = $$*)
Apply labels (or colors) from the first array to a copy of the current/given scale. Can also apply a single color to the whole scale.

### labelsOf(*scale = $$*)
Obtain an array of labels of the current/given scale.

### labs(*x*)
Calculate the logarithmic absolute value. Inputs below unison are inverted.

### log(*x*, *y = E*)
Calculate the logarithm of x base y. Base defaults to E.

### log10(*x*)
Calculate the logarithm of x base 10.

### log2(*x*)
Calculate the logarithm of x base 2.

### mergeOffset(*offsets*, *overflow = "drop"*, *scale = $$*)
Merge the given offset or polyoffset of the current/given scale onto itself. `overflow` is one of 'keep', 'drop' or 'wrap' and controls what to do with offset intervals outside of current bounds.

### mos(*numberOfLargeSteps*, *numberOfSmallSteps*, *sizeOfLargeStep = 2*, *sizeOfSmallStep = 1*, *up = niente*, *down = niente*, *equave = 2*)
Generate a Moment-Of-Symmetry scale with the given number number of large and small steps.   `up` defines the brightness of the mode i.e. the number of major intervals from the root.   Alternatively `down` defines the darkness of the mode i.e. the number of minor intervals from the root.   The default `equave` is the octave `2/1`.

### mtof(*index*)
Convert MIDI note number to absolute frequency.

### mul(*...factors*)
Calculate the (linear) product of the arguments i.e. the logarithmic sum.

### NFJS(*interval*)
Convert interval to (relative) FJS using neutral comma flavors.

### numerator(*x*)
Calculate the numerator of x in reduced form.

### o(*scale = $$*)
Obtain a copy of the current/given scale in the default overtonal interpretation.

### octaplex(*b0*, *b1*, *b2*, *b3*, *equave = 2*, *withUnity = false*)
Generate a 4-dimensional octaplex a.k.a. 20-cell from the given basis intervals.

### oddLimit(*limit*, *equave = 2*)
Generate all fractions with odd limit <= `limit` reduced to between 1 (exclusive) and `equave` (inclusive).

### oddLimitOf(*x*, *equave = 2*)
Calculate the odd limit of x. Here 'odd' means not divisible by the equave.

### organize(*tolerance = niente*, *action = "simplest"*, *preserveBoundary = false*, *scale = $$*)
Reduce the current/given scale by its last interval, sort the result and filter out duplicates.  If `tolerance` is given near-duplicates are coalesced instead using the given `action`.  If `preserveBoundary` is `true` intervals close to unison and the equave are not eliminated.

### organized(*tolerance = niente*, *action = "simplest"*, *preserveBoundary = false*, *scale = $$*)
Obtain a copy of the current/given scale reduced by its last interval, sorted and with duplicates filtered out.  If `tolerance` is given near-duplicates are coalesced instead using the given `action`.  If `preserveBoundary` is `true` intervals close to unison and the equave are not eliminated.

### parallelotope(*basis*, *ups = niente*, *downs = niente*, *equave = 2*)
Span a parallelotope by extending a basis combinatorically. `ups` defaults to all ones while `downs` defaults to all zeros.

### periodiff(*array*)
Calculate the geometric differences of the periodic interval pattern.

### periostack(*guideGenerator*, *array = $$*)
Stack the current/given inflections along with the guide generator into a periodic sequence of steps.

### pow(*x*, *y*)
Calculate x to the power of y.

### prod(*factors = $$*)
Calculate the (linear) product of the factors or the current scale i.e. the logarithmic sum.

### randomVariance(*amount*, *varyEquave = false*, *scale = $$*)
Add random variance to the current/given scale.

### randomVaried(*amount*, *varyEquave = false*, *scale = $$*)
Obtain a copy of the current/given scale with random variance added.

### range(*start*, *stop = niente*, *step = 1*)
Obtain an array of integers from `start` to `stop - 1`. When only a single parameter is given `range(0, n)` is returned.

### rank2(*generator*, *up*, *down = 0*, *period = 2*, *numPeriods = 1*)
Generate a finite segment of a Rank-2 scale generated by stacking the given generator against the given period (or the octave `2/1` by default). `up` and `down` must be multiples of `numPeriods`.

### realizeWord(*word*, *sizes*, *equave = niente*)
Realize a scale word like "LLsLLLs" as a concrete scale with the given step sizes. One step size may be omitted and inferred based on the size of the `equave` (default `2`).

### reduce(*scale = $$*)
Reduce the current/given scale by its equave. Issue a warning if the scale was already reduced.

### reduced(*scale = $$*)
Obtain a copy of the current/given scale reduced by its equave. Issue a warning if the scale was already reduced.

### reflect(*scale = $$*)
Reflect the current/given scale about unison.

### reflected(*scale = $$*)
Obtain a copy of the current/given scale reflected about unison.

### relin(*interval*)
Convert interval to relative linear representation.

### relog(*interval*)
Convert interval to relative logarithmic representation.

### repeat(*times = 2*, *scale = $$*)
Stack the current scale on top of itself. Clears the scale if the number of repeats is zero.

### repeated(*times = 2*, *scale = $$*)
Stack the current/given scale on top of itself.

### repeatedLinear(*times = 2*, *scale = $$*)
Repeat the current/given scale shifted linearly each time.

### repeatLinear(*times = 2*, *scale = $$*)
Repeat the current/given scale shifted linearly each time. Clears the scale if the number of repeats is zero.

### replace(*interval*, *replacement*, *scale = $$*)
Replace occurences of `interval` in the current/given scale by `replacement`.

### replaced(*interval*, *replacement*, *scale = $$*)
Obtain a copy of the current/given scale with occurences of `interval` replaced by `replacement`.

### replaceStep(*step*, *replacement*, *scale = $$*)
Replace relative occurences of `step` in the current/given scale by `replacement`.

### retrovert(*scale = $$*)
Retrovert the current/given scale (negative harmony i.e reflect and transpose).

### retroverted(*scale = $$*)
Obtain an retroverted copy of the current/given scale (negative harmony i.e. reflect and transpose).

### revpose(*scale = $$*)
Change the sounding direction. Converts a descending scale to an ascending one.

### revposed(*scale = $$*)
Obtain a copy of the current/given scale that sounds in the opposite direction.

### rotate(*onto = 1*, *scale = $$*)
Rotate the current/given scale onto the given degree.

### rotated(*onto = 1*, *scale = $$*)
Obtain a copy of the current/given scale rotated onto the given degree.

### sanitize(*interval*)
Get rid of interval formatting, color and label.

### sign(*x*)
Calculate the sign of x.

### sinh(*x*)
Calculate the hyperbolic sine of x.

### sqrt(*x*)
Calculate the square root of the input.

### stack(*array = $$*)
Cumulatively stack the current/given intervals on top of each other.

### stacked(*array*)
Obtain a copy of the current/given intervals cumulatively stacked on top of each other.

### stackLinear(*array = $$*)
Cumulatively sum the numbers of the current/given array.

### stepReplaced(*step*, *replacement*, *scale = $$*)
Obtain a copy of the current/given scale with relative occurences of `step` replaced by `replacement`.

### stretch(*amount*, *scale = $$*)
Stretch the current/given scale by the given amount. A value of `1` corresponds to no change.

### stretched(*amount*, *scale = $$*)
Obtain a copy of the current/given scale streched by the given amount. A value of `1` corresponds to no change.

### subharmonics(*start*, *end*)
Generate a subharmonic segment including the given start and end points.

### subharmonicsOf(*overtone*, *scale = $$*)
Obtain a copy of the current/given scale quantized to subharmonics of the given overtone.

### subset(*degrees*, *scale = $$*)
Only keep the given degrees of the current/given scale. Omitting the zero degree rotates the scale.

### subsetOf(*degrees*, *scale = $$*)
Obtain a copy of the current/given scale with only the given degrees kept. Omitting the zero degree rotates the scale.

### sum(*terms = $$*)
Calculate the (linear) sum of the terms or the current scale.

### tanh(*x*)
Calculate the hyperbolic tangent of x.

### tet(*divisions*, *equave = 2*)
Generate an equal temperament with the given number of divisions of the given equave/octave.

### toHarmonics(*fundamental*, *scale = $$*)
Quantize the current/given scale to harmonics of the given fundamental.

### toSubharmonics(*overtone*, *scale = $$*)
Quantize the current/given scale to subharmonics of the given overtone.

### trap(*message*)
Produce a function that fails with the given message when called.

### tune(*a*, *b*, *numIter = 1*, *weighting = "tenney"*)
Find a combination of two vals that is closer to just intonation.

### tune3(*a*, *b*, *c*, *numIter = 1*, *weighting = "tenney"*)
Find a combination of three vals that is closer to just intonation.

### u(*scale = $$*)
Obtain a undertonal reflection of the current/given overtonal scale.

### unperiostack(*array = $$*)
Convert the current/given periodic sequence of steps into inflections of the last interval as the guide generator.

### unstack(*array = $$*)
Unstack the current/given scale into steps.

### unstacked(*array*)
Calculate the relative steps in the current/given scale.

### values(*record*)
Obtain an array of values of the record.

### vao(*denominator*, *maxNumerator*, *divisions = 12*, *tolerance = 5.0*, *equave = 2*)
Generate a vertically aligned object i.e. a subset of the harmonic series that sounds like the given equal temperament (default `12`) within the given tolerance (default `5c`). Harmonics equated by the `equave` (default `2/1`) are only included once. The returned segment begins at unison.

### vbool(*value*)
Convert value to a boolean. Vectorizes over arrays.

### void()
Get rid of expression results. `void(++i)` increments the value but doesn't push anything onto the scale.

### weilHeight(*x*)
Calculate the Weil height of the interval. Natural logarithm of the maximum of numerator or denominator.

### wellTemperament(*commaFractions*, *comma = 81/80*, *down = 0*, *generator = 3/2*, *period = 2*)
Generate a well-temperament by cumulatively modifying the pure fifth `3/2` (or a given generator) by fractions of the syntonic/given comma.

### withOffset(*offsets*, *overflow = "drop"*, *scale = $$*)
Obtain a copy of the current/given scale with the given offset or polyoffset merged into it. `overflow` is one of 'keep', 'drop' or 'wrap' and controls what to do with offset intervals outside of current bounds.

