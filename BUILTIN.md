# SonicWeave standard library
<!-- This file has been auto-generated by `npm run autodoc` i.e. scripts/builtin-docs.ts !-->

## Built-in functions

### abs(*interval*)
Calculate the absolute value of the interval.

### absolute(*interval*)
Convert interval to absolute representation.

### absoluteFJS(*interval*, *flavor = ""*)
Convert interval to absolute FJS.

### acos(*x*)
Calculate acos x.

### arrayReduce(*reducer*, *scale = $$*, *initialValue*)
Reduce the given/current scale to a single value by the `reducer` riff which takes an accumulator, the current value, the current index and the array as arguments.

### arrayRepeat(*count*, *scale = $$*)
Repeat the given/current array or string `count` times.

### asin(*x*)
Calculate asin x.

### atan(*x*)
Calculate atan x.

### atan2(*y*, *x*)
Calculate atan2(y, x) which is the angle between (1, 0) and (x, y), chosen to lie in (−π; π], positive anticlockwise.

### atanXY(*x*, *y*)
Calculate atanXY(x, y) = atan2(y, x) which is the angle between (1, 0) and (x, y), chosen to lie in (−π; π], positive anticlockwise.

### bleach(*interval*)
Get rid of interval coloring and label.

### bool(*value*)
Convert value to a boolean.

### ceil(*interval*)
Round value up to the nearest integer.

### cents(*interval*, *fractionDigits*)
Convert interval to cents.

### centsColor(*interval*)
Color based on the size of the interval. Hue wraps around every 1200 cents.

### clear(*scale = $$*)
Remove the contents of the current/given scale.

### clz32(*x*)
Calculate clz32 x.

### cologarithmic(*interval*)
Convert interval to cologarithmic representation.

### colorOf(*interval*)
Return the color of the interval.

### concat(*first*, *...rest*)
Combine two or more arrays/strings.

### cos(*x*)
Calculate cos x.

### cosJIP(*val*, *weighting = "tenney"*)
Cosine of the angle between the val and the just intonation point. Weighting is either "none" or "tenney".

### decimal(*interval*, *fractionDigits*)
Convert interval to a decimal number.

### dir(*arg*)
Obtain the javascript representation of the value.

### dislodge(*element*, *scale = $$*)
Remove and return the first element equal to the given one from the current/given scale.

### distill(*tester*, *scale = $$*)
Remove intervals from the given/current scale that evaluate to `false` according to the `tester` riff.

### doc(*riff*)
Obtain the docstring of the given riff.

### entries(*record*)
Obtain an array of `[key, value]` pairs of the record.

### equaveOf(*val*)
Return the equave of the val.

### expm1(*x*)
Calculate expm1 x.

### extend(*first*, *...rest*)
Extend the first array with the contents of the rest.

### factorColor(*interval*)
Color an interval based on its prime factors.

### fareyInterior(*maxDenominator*)
Generate the interior of the n'th Farey sequence i.e. all fractions between 0 and 1 exclusive with denominater below or at the given limit.

### fareySequence(*maxDenominator*)
Generate the n'th Farey sequence i.e. all fractions between 0 and 1 inclusive with denominater below or at the given limit.

### filter(*tester*, *scale = $$*)
Obtain a copy of the given/current scale containing values that evaluate to `true` according to the `tester` riff.

### FJS(*interval*, *flavor = ""*)
Convert interval to (relative) FJS.

### flatten(*array*, *depth*)
Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth (default `Infinity`).

### floor(*interval*)
Round value down to the nearest integer.

### fraction(*interval*, *tolerance*, *preferredNumerator*, *preferredDenominator*)
Convert interval to a fraction. Throws an error if conversion is impossible and no tolerance (in cents) for approximation is given.

### fround(*x*)
Calculate fround x.

### gcd(*...intervals*)
Obtain the largest (linear) multiplicative factor shared by all intervals or the current scale.

### hasConstantStructure(*scale = $$*)
Returns `true` if the current/given scale has constant structure (i.e. every scale degree is unambiguous).

### help(*riff*)
Print information about the given riff to the console.

### hsl(*hue*, *saturation*, *lightness*)
HSL color (Hue range 0-360, Saturation range 0-100, Lightness range 0-100).

### hsla(*hue*, *saturation*, *lightness*, *alpha*)
HSLA color (Hue range 0-360, Saturation range 0-100, Lightness range 0-100, Alpha range 0-1).

### imul(*x*)
Calculate imul x.

### insert(*interval*, *scale = $$*)
Insert an interval into the current/given scale keeping it sorted.

### int(*interval*)
Convert value to an integer. Throws an error if conversion is impossible.

### isAbsolute(*interval*)
Return `true` if the interval belongs to the absolute echelon.

### isArray(*value*)
Return `true` if the value is an array.

### isBoolean(*value*)
Return `true` if the value is a boolean.

### isColor(*value*)
Return `true` if the value is a color.

### isFunction(*value*)
Return `true` if the value is a riff or an arrow function.

### isInt(*interval*)
Return `true` if the interval is an integer.

### isInterval(*value*)
Return `true` if the value is an interval.

### isLinear(*interval*)
Return `true` if the interval belongs to the linear domain.

### isLogarithmic(*interval*)
Return `true` if the interval belongs to the logarithmic domain.

### isPrime(*n*)
Return `true` if `n` is a prime number, `false` otherwise.

### isRadical(*interval*)
Return `true` if the interval is an nth root.

### isRational(*interval*)
Return `true` if the interval is a rational number.

### isRelative(*interval*)
Return `true` if the interval belongs to the relative echelon.

### isString(*value*)
Return `true` if the value is a string.

### JIP(*interval*)
The Just Intonation Point. Converts intervals to real cents.

### kCombinations(*set*, *k*)
Obtain all k-sized combinations in a set

### keepUnique(*scale = $$*)
Only keep unique intervals in the current/given scale.

### labelAbsoluteFJS(*interval*, *flavor = ""*)
Convert interval to absolute FJS and label without octaves. Color black if there are accidentals, white otherwise.

### labelOf(*interval*)
Return the label of the interval.

### lcm(*...intervals*)
Obtain the smallest (linear) interval that shares all intervals or the current scale as multiplicative factors.

### length(*scale = $$*)
Return the number of intervals in the scale.

### linear(*interval*)
Convert interval to linear representation.

### log1p(*x*)
Calculate log1p x.

### logarithmic(*interval*)
Convert interval to logarithmic representation.

### map(*mapper*, *scale = $$*)
Map a riff over the given/current scale producing a new scale.

### maximum(*...args*)
Obtain the argument with the maximum value.

### minimum(*...args*)
Obtain the argument with the minimum value.

### monzo(*interval*)
Convert interval to a prime count vector a.k.a. monzo.

### mosSubset(*numberOfLargeSteps*, *numberOfSmallSteps*, *sizeOfLargeStep*, *sizeOfSmallStep*, *up*, *down*)
Calculate a subset of equally tempered degrees with maximum variety two per scale degree.

### nedji(*interval*, *preferredNumerator*, *preferredDenominator*, *preferredEquaveNumerator*, *preferredEquaveDenominator*)
Convert interval to N steps of equally divided just intonation.

### numComponents(*value*)
Get/set the number of prime exponents to support in monzos. Also sets the length of vals.

### pop(*scale = $$*, *index*)
Remove and return the last interval in the current/given scale. Optionally an index to pop may be given.

### popAll(*scale = $$*)
Remove and return all intervals in the current/given scale.

### PrimeMapping(*...newPrimes*)
Construct a prime mapping for tempering intervals to specified cents. Remaining primes are left untempered.

### primes(*start*, *end*)
Obtain an array of prime numbers such that start <= p <= end. Or p <= start if end is omitted.

### print(*...args*)
Print the arguments to the console.

### push(*interval*, *scale = $$*, *index*)
Append an interval onto the current/given scale. Optionally an index to push after may be given.

### radical(*interval*, *maxIndex*, *maxHeight*)
Convert interval to a radical expression. Throws an error if conversion is impossible and no maximum index (2 means square root, 3 means cube root, etc.) for approximation is given.

### random()
Obtain a random value between (linear) 0 and 1.

### randomCents()
Obtain random cents between (logarithmic) 0.0c and 1.0c.

### relative(*interval*)
Convert interval to relative representation.

### remap(*mapper*, *scale = $$*)
Map a riff over the given/current scale replacing the contents.

### repr(*value*)
Obtain a string representation of the value (with color and label).

### reverse(*scale = $$*)
Reverse the order of the current/given scale.

### reversed(*scale = $$*)
Obtain a copy of the current/given scale in reversed order.

### rgb(*red*, *green*, *blue*)
RGB color (Red range 0-255, Green range 0-255, Blue range 0-255).

### rgba(*red*, *green*, *blue*, *alpha*)
RGBA color (Red range 0-255, Green range 0-255, Blue range 0-255, Alpha range 0-1).

### round(*interval*)
Round value to the nearest integer.

### shift(*scale = $$*)
Remove and return the first interval in the current/given scale.

### simplify(*interval*)
Get rid of interval formatting.

### sin(*x*)
Calculate sin x.

### slice(*array*, *indexStart*, *indexEnd*)
Obtain a slice of a string or scale between the given indices.

### sort(*scale = $$*, *compareFn*)
Sort the current/given scale in ascending order.

### sorted(*scale = $$*, *compareFn*)
Obtain a sorted copy of the current/given scale in ascending order.

### stepString(*scale = $$*)
Obtain the step string associated with the scale e.g. "LLsLLLs" for Ionian.

### str(*value*)
Obtain a string representation of the value (w/o color or label).

### tail(*interval*, *index*)
Return the higher prime tail of an interval starting from the given index. Prime 2 has index 0.

### tan(*x*)
Calculate tan x.

### tenneyHeight(*interval*)
Calculate the Tenney height of the interval. Natural logarithm of numerator times denominator.

### track(*interval*)
Attach a tracking ID to the interval.

### trackingIds(*interval*)
Obtain an array of the tracking IDs attached to the interval.

### trunc(*interval*)
Truncate value towards zero to the nearest integer.

### uniquesOf(*scale = $$*)
Obtain a copy of the current/given scale with only unique intervals kept.

### unshift(*interval*, *scale = $$*)
Prepend an interval at the beginning of the current/given scale.

### withEquave(*val*, *equave*)
Change the equave of the val.

### zip(*...args*)
Combine elements of each array into tuples until one of them is exhausted.

### zipLongest(*...args*)
Combine elements of each array into tuples until all of them are exhausted. Pads missing values with `niente`.

## Prelude functions

### ablin(*interval*)
Convert interval to absolute linear representation.

### ablog(*interval*)
Convert interval to absolute logarithmic representation.

### absoluteHEJI(*interval*)
Convert interval to absolute FJS using HEJI comma flavors.

### absoluteNFJS(*interval*)
Convert interval to absolute FJS using neutral comma flavors.

### acosh(*x*)
Calculate the inverse hyperbolic cosine of x.

### add(*...terms*)
Calculate the (linear) sum of the arguments.

### antiperiodiff(*constantOfIntegration*, *array*)
Calculate the cumulative geometric sums of a periodic difference pattern. Undoes what periodiff does.

### asinh(*x*)
Calculate the inverse hyperbolic sine of x.

### atanh(*x*)
Calculate the inverse hyperbolic tangent of x.

### avg(*...terms*)
Calculate the arithmetic mean of the terms.

### bpm(*beats*)
Calculate the frequency corresponding to the given number of beats per minute.

### cbrt(*x*)
Calculate the cube root of the input.

### circleDifference(*a*, *b*, *equave = 2*)
Calculate the geometric difference of two intervals on a circle.

### circleDistance(*a*, *b*, *equave = 2*)
Calculate the geometric distance of two intervals on a circle.

### coalesce(*tolerance = 3.5*, *action = "simplest"*, *scale = $$*)
Coalesce intervals in the current/given scale separated by `tolerance` (default 3.5 cents) into one. `action` is one of 'simplest', 'lowest', 'highest', 'avg', 'havg' or 'geoavg' defaulting to 'simplest'.

### coalesced(*tolerance = 3.5*, *action = "simplest"*, *scale = $$*)
Obtain a copy of the current/given scale where groups of intervals separated by `tolerance` are coalesced into one. `action` is one of 'simplest', 'lowest', 'highest', 'avg', 'havg' or 'geoavg'.

### colorsOf(*scale = $$*)
Obtain an array of colors of the current/given scale.

### concordanceShell(*denominator*, *maxNumerator*, *divisions = 12*, *tolerance = 5.0*, *equave = 2*)
Generate a concordance shell i.e. a vertically aligned object reduced to an equal temperament. Intervals are labeled by their harmonics.

### cosh(*x*)
Calculate the hyperbolic cosine of x.

### cps(*factors*, *count*, *equave = 2*, *withUnity = false*)
Generate a combination product set from the given factors and combination size.

### csgs(*generators*, *ordinal = 1*, *period = 2*, *numPeriods = 1*, *maxSize = 100*)
Generate a constant structure generator sequence. Zero ordinal corresponds to the (trivial) stack of all generators while positive ordinals denote scales with constant structure ordered by increasing size.

### cumprod(*array*)
Calculate the cumulative products of the factors in the array i.e. logarithmic cumulative sums.

### cumsum(*array*)
Calculate the cumulative sums of the terms in the array.

### denominator(*x*)
Calculate the denominator of x in reduced form.

### diff(*array*)
Calculate the (linear) differences between the terms.

### edColors(*divisions = 12*, *offset = 0*, *equave = 2*)
Color every interval in the scale with hue repeating every step of an equal division of `equave`. `offset` rotates the hue wheel.

### elevate(*scale = $$*)
Remove denominators and make the root explicit in the current/given scale.

### elevated(*scale = $$*)
Obtain a copy of the current/given scale with denominators removed and the root made explicit.

### enumerate(*array = $$*)
Produce an array of [index, element] pairs from the given current/given array.

### equalize(*divisions*, *scale = $$*)
Quantize the current/given scale to given equal divisions of its equave.

### equalized(*divisions*, *scale = $$*)
Obtain a copy of the current/given scale quantized to given equal divisions of its equave.

### eulerGenus(*guide*, *root = 1*, *equave = 2*)
Span a lattice from all divisors of the guide-tone rotated to the root-tone.

### exp(*x*)
Calculate e raised to the power of x.

### flatRepeat(*times = 2*, *scale = $$*)
Repeat the current/given intervals as-is without accumulating equaves. Clears the scale if the number of repeats is zero.

### ftom(*freq*)
Convert absolute frequency to MIDI note number / MTS value (fractional semitones with A440 = 69).

### geoavg(*...factors*)
Calculate the geometric mean of the factors.

### geodiff(*array*)
Calculate the geometric differences between the factors.

### ground(*scale = $$*)
Use the first interval in the current/given scale as the implicit unison.

### grounded(*scale = $$*)
Obtain a copy of the current/given scale that uses the first interval as the implicit unison.

### gs(*generators*, *size*, *period = 2*, *numPeriods = 1*)
Stack a periodic array of generators up to the given size which must be a multiple of the number of periods.

### harmonicsOf(*fundamental*, *scale = $$*)
Obtain a copy of the current/given scale quantized to harmonics of the given fundamental.

### havg(*...terms*)
Calculate the harmonic mean of the terms.

### HEJI(*interval*)
Convert interval to (relative) FJS using HEJI comma flavors.

### hypot(*...args*)
Calculate the square root of the sum of squares of the arguments.

### keys(*record*)
Obtain an array of keys of the record.

### label(*labels*, *scale = $$*)
Apply labels (or colors) from the first array to the current/given scale. Can also apply a single color to the whole scale.

### labeled(*labels*, *scale = $$*)
Apply labels (or colors) from the first array to a copy of the current/given scale. Can also apply a single color to the whole scale.

### labelsOf(*scale = $$*)
Obtain an array of labels of the current/given scale.

### log(*x*, *y = E*)
Calculate the logarithm of x base y. Base defaults to E.

### log10(*x*)
Calculate the logarithm of x base 10.

### log2(*x*)
Calculate the logarithm of x base 2.

### mergeOffset(*offsets*, *overflow = "drop"*, *scale = $$*)
Merge the given offset or polyoffset of the current/given scale onto itself. `overflow` is one of 'keep', 'drop' or 'wrap' and controls what to do with offset intervals outside of current bounds.

### mos(*numberOfLargeSteps*, *numberOfSmallSteps*, *sizeOfLargeStep = 2*, *sizeOfSmallStep = 1*, *up = niente*, *down = niente*, *equave = 2*)
Generate a Moment-Of-Symmetry scale with the given number number of large and small steps.   `up` defines the brightness of the mode i.e. the number of major intervals from the root.   Alternatively `down` defines the darkness of the mode i.e. the number of minor intervals from the root.   The default `equave` is the octave `2/1`.

### mtof(*index*)
Convert MIDI note number to absolute frequency.

### mul(*...factors*)
Calculate the (linear) product of the arguments i.e. the logarithmic sum.

### NFJS(*interval*)
Convert interval to (relative) FJS using neutral comma flavors.

### numerator(*x*)
Calculate the numerator of x in reduced form.

### o(*scale = $$*)
Obtain a copy of the current/given scale in the default overtonal interpretation.

### octaplex(*b0*, *b1*, *b2*, *b3*, *equave = 2*, *withUnity = false*)
Generate a 4-dimensional octaplex a.k.a. 20-cell from the given basis intervals.

### oddLimit(*limit*, *equave = 2*)
Generate all fractions with odd limit <= `limit` reduced to between 1 (exclusive) and `equave` (inclusive).

### oddLimitOf(*x*, *equave = 2*)
Calculate the odd limit of x. Here 'odd' means not divisible by the equave.

### organize(*tolerance = niente*, *action = "simplest"*, *scale = $$*)
Reduce the current/given scale by its last interval, sort the result and filter out duplicates. If `tolerance` is given near-duplicates are coalesced instead using the given `action`.

### organized(*tolerance = niente*, *action = "simplest"*, *scale = $$*)
Obtain a copy of the current/given scale reduced by its last interval, sorted and with duplicates filtered out. If `tolerance` is given near-duplicates are coalesced instead using the given `action`.

### parallelotope(*basis*, *ups = niente*, *downs = niente*, *equave = 2*)
Span a parallelotope by extending a basis combinatorically. `ups` defaults to all ones while `downs` defaults to all zeros.

### periodiff(*array*)
Calculate the geometric differences of the periodic interval pattern.

### periostack(*guideGenerator*, *array = $$*)
Stack the current/given inflections along with the guide generator into a periodic sequence of steps.

### pow(*x*, *y*)
Calculate x to the power of y.

### prod(*factors = $$*)
Calculate the (linear) product of the factors or the current scale i.e. the logarithmic sum.

### randomVariance(*amount*, *varyEquave = false*, *scale = $$*)
Add random variance to the current/given scale.

### randomVaried(*amount*, *varyEquave = false*, *scale = $$*)
Obtain a copy of the current/given scale with random variance added.

### rank2(*generator*, *up*, *down = 0*, *period = 2*, *numPeriods = 1*)
Generate a finite segment of a Rank-2 scale generated by stacking the given generator against the given period (or the octave `2/1` by default). `up` and `down` must be multiples of `numPeriods`.

### reduce(*scale = $$*)
Reduce the current/given scale by its equave.

### reduced(*scale = $$*)
Obtain a copy of the current/given scale reduced by its equave.

### reflect(*scale = $$*)
Reflect the current/given scale about unison.

### reflected(*scale = $$*)
Obtain a copy of the current/given scale reflected about unison.

### relin(*interval*)
Convert interval to relative linear representation.

### relog(*interval*)
Convert interval to relative logarithmic representation.

### repeat(*times = 2*, *scale = $$*)
Stack the current scale on top of itself. Clears the scale if the number of repeats is zero.

### repeated(*times = 2*, *scale = $$*)
Stack the current/given scale on top of itself.

### replace(*interval*, *replacement*, *scale = $$*)
Replace occurences of `interval` in the current/given scale by `replacement`.

### replaced(*interval*, *replacement*, *scale = $$*)
Obtain a copy of the current/given scale with occurences of `interval` replaced by `replacement`.

### replaceStep(*step*, *replacement*, *scale = $$*)
Replace relative occurences of `step` in the current/given scale by `replacement`.

### retrovert(*scale = $$*)
Retrovert the current/given scale (negative harmony i.e reflect and transpose).

### retroverted(*scale = $$*)
Obtain an retroverted copy of the current/given scale (negative harmony i.e. reflect and transpose).

### revpose(*scale = $$*)
Change the sounding direction. Converts a descending scale to an ascending one.

### revposed(*scale = $$*)
Obtain a copy of the current/given scale that sounds in the opposite direction.

### rotate(*onto = 1*, *scale = $$*)
Rotate the current/given scale onto the given degree.

### rotated(*onto = 1*, *scale = $$*)
Obtain a copy of the current/given scale rotated onto the given degree.

### sanitize(*interval*)
Get rid of interval formatting, color and label.

### sign(*x*)
Calculate the sign of x.

### sinh(*x*)
Calculate the hyperbolic sine of x.

### sqrt(*x*)
Calculate the square root of the input.

### stack(*array = $$*)
Cumulatively stack the current/given intervals on top of each other.

### stacked(*array*)
Obtain a copy of the current/given intervals cumulatively stacked on top of each other.

### stackLinear(*array = $$*)
Cumulatively sum the numbers of the current/given array.

### stepReplaced(*step*, *replacement*, *scale = $$*)
Obtain a copy of the current/given scale with relative occurences of `step` replaced by `replacement`.

### stretch(*amount*, *scale = $$*)
Stretch the current/given scale by the given amount. A value of `1` corresponds to no change.

### stretched(*amount*, *scale = $$*)
Obtain a copy of the current/given scale streched by the given amount. A value of `1` corresponds to no change.

### subharmonics(*start*, *end*)
Generate a subharmonic segment including the given start and end points.

### subharmonicsOf(*overtone*, *scale = $$*)
Obtain a copy of the current/given scale quantized to subharmonics of the given overtone.

### subset(*degrees*, *scale = $$*)
Only keep the given degrees of the current/given scale. Omitting the zero degree rotates the scale.

### subsetOf(*degrees*, *scale = $$*)
Obtain a copy of the current/given scale with only the given degrees kept. Omitting the zero degree rotates the scale.

### sum(*terms = $$*)
Calculate the (linear) sum of the terms or the current scale.

### tanh(*x*)
Calculate the hyperbolic tangent of x.

### tet(*divisions*, *equave = 2*)
Generate an equal temperament with the given number of divisions of the given equave/octave.

### toHarmonics(*fundamental*, *scale = $$*)
Quantize the current/given scale to harmonics of the given fundamental.

### toSubharmonics(*overtone*, *scale = $$*)
Quantize the current/given scale to subharmonics of the given overtone.

### tune(*a*, *b*, *numIter = 1*, *weighting = "tenney"*)
Find a combination of two vals that is closer to just intonation.

### tune3(*a*, *b*, *c*, *numIter = 1*, *weighting = "tenney"*)
Find a combination of three vals that is closer to just intonation.

### u(*scale = $$*)
Obtain a undertonal reflection of the current/given overtonal scale.

### unperiostack(*array = $$*)
Convert the current/given periodic sequence of steps into inflections of the last interval as the guide generator.

### unstack(*array = $$*)
Unstack the current/given scale into steps.

### unstacked(*array*)
Calculate the relative steps in the current/given scale.

### values(*record*)
Obtain an array of values of the record.

### vao(*denominator*, *maxNumerator*, *divisions = 12*, *tolerance = 5.0*, *equave = 2*)
Generate a vertically aligned object i.e. a subset of the harmonic series that sounds like the given equal temperament (default `12`) within the given tolerance (default `5c`). Harmonics equated by the `equave` (default `2/1`) are only included once. The returned segment begins at unison.

### void()
Get rid of expression results. `void(i++)` increments the value but doesn't push anything onto the scale.

### wellTemperament(*commaFractions*, *comma = 81/80*, *down = 0*, *generator = 3/2*, *period = 2*)
Generate a well-temperament by cumulatively modifying the pure fifth `3/2` (or a given generator) by fractions of the syntonic/given comma.

### withOffset(*offsets*, *overflow = "drop"*, *scale = $$*)
Obtain a copy of the current/given scale with the given offset or polyoffset merged into it. `overflow` is one of 'keep', 'drop' or 'wrap' and controls what to do with offset intervals outside of current bounds.

